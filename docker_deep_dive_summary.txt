ch.4
    1. Can think of images as "class", container as "instance". Surely they are not the same
    2. inspect container shell with docker run -it
    3. git pull a directory, build an image and run it as container. pretty cool.

ch.5 the docker engine
    high-level view:
    1. daemon : used to be a bulk of what "docker" is, continously being refactor and modularized.
    REST API, authentication, orchestration, security, core networkingmodulized

    2. containerd: manage container lifecycle operations - start|stop|pause|rm,
    but it also involve in image push / pull overtime.
    3. runc - single purpose: create containers

    Now that all essential container function is pulled out from daemon,
    it is possible to upgrade docker daemon version without stopping
    any container.

    rest of the chapter is just setting up key-pairs security stuff, skipped.

ch.6 docker image
    - docker images is small and fast because only necessary component is in the image.
    - it is build with layer, say layer for OS, a layer for python, and a layer for source code.
    - linux images tend to be a lot smaller than windows operations
    - command; docker images ls/rm/pull/push

ch.7 docker container
    - it is best practice to docker stop > docker rm, then docker rm -f. So the container can stop cleanly.
    - data is not stored in the container, instead it is store in host with docker volume. Data will not be loss
    by stopping container, but rm it.
    - restart policy:
        a. always: always restart unless explicity stopped
        b. unless-stopped.  smae as always, but will not restart when daemon restarts.
        c. on -failure: restart if container exist with non-zero exit code

